// vesa64.c - VESA Framebuffer Text Mode Driver
// VGA text mode (0xB8000) yerine Multiboot2 framebuffer kullanır.
// Font: 8x16 pixel, gömülü PC Screen Font (PSF1 uyumlu bitmap)

#include <stdint.h>
#include <stddef.h>

// ============================================================================
// Multiboot2'nin sağladığı framebuffer bilgileri
// boot64_unified.asm tarafından doldurulur
// ============================================================================
extern uint64_t framebuffer_addr;
extern uint32_t framebuffer_pitch;   // satır başına byte
extern uint32_t framebuffer_width;   // pixel cinsinden genişlik
extern uint32_t framebuffer_height;  // pixel cinsinden yükseklik
extern uint8_t  framebuffer_bpp;     // bits per pixel (genellikle 32)

// ============================================================================
// Dahili 8x16 bitmap font (ASCII 32-127, temel PC font)
// Her karakter 16 byte = 16 satır x 8 bit
// ============================================================================
static const uint8_t font8x16[96][16] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x20 ' '
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, // 0x21 '!'
    {0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x22 '"'
    {0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00}, // 0x23 '#'
    {0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00,0x00}, // 0x24 '$'
    {0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00}, // 0x25 '%'
    {0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, // 0x26 '&'
    {0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x27 '''
    {0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00}, // 0x28 '('
    {0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00}, // 0x29 ')'
    {0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x2A '*'
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x2B '+'
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00}, // 0x2C ','
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x2D '-'
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, // 0x2E '.'
    {0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00}, // 0x2F '/'
    {0x00,0x00,0x7C,0xC6,0xCE,0xDE,0xF6,0xE6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x30 '0'
    {0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00}, // 0x31 '1'
    {0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00}, // 0x32 '2'
    {0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x33 '3'
    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00}, // 0x34 '4'
    {0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x35 '5'
    {0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x36 '6'
    {0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00}, // 0x37 '7'
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x38 '8'
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00}, // 0x39 '9'
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // 0x3A ':'
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00}, // 0x3B ';'
    {0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00}, // 0x3C '<'
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x3D '='
    {0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00}, // 0x3E '>'
    {0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, // 0x3F '?'
    {0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0xC4,0x7C,0x00,0x00,0x00,0x00}, // 0x40 '@'
    {0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, // 0x41 'A'
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00}, // 0x42 'B'
    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00}, // 0x43 'C'
    {0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00}, // 0x44 'D'
    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00}, // 0x45 'E'
    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00}, // 0x46 'F'
    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00}, // 0x47 'G'
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, // 0x48 'H'
    {0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, // 0x49 'I'
    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00}, // 0x4A 'J'
    {0x00,0x00,0xE6,0x66,0x6C,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00}, // 0x4B 'K'
    {0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00}, // 0x4C 'L'
    {0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, // 0x4D 'M'
    {0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, // 0x4E 'N'
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x4F 'O'
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00}, // 0x50 'P'
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00}, // 0x51 'Q'
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00}, // 0x52 'R'
    {0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x53 'S'
    {0x00,0x00,0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, // 0x54 'T'
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x55 'U'
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00}, // 0x56 'V'
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00}, // 0x57 'W'
    {0x00,0x00,0xC6,0xC6,0x6C,0x6C,0x38,0x38,0x6C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00}, // 0x58 'X'
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, // 0x59 'Y'
    {0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00}, // 0x5A 'Z'
    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00}, // 0x5B '['
    {0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00}, // 0x5C '\'
    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00}, // 0x5D ']'
    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x5E '^'
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00}, // 0x5F '_'
    {0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x60 '`'
    {0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, // 0x61 'a'
    {0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00}, // 0x62 'b'
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x63 'c'
    {0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, // 0x64 'd'
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x65 'e'
    {0x00,0x00,0x1C,0x36,0x32,0x30,0x78,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00}, // 0x66 'f'
    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00}, // 0x67 'g'
    {0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00}, // 0x68 'h'
    {0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, // 0x69 'i'
    {0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00}, // 0x6A 'j'
    {0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00}, // 0x6B 'k'
    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, // 0x6C 'l'
    {0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00}, // 0x6D 'm'
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00}, // 0x6E 'n'
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x6F 'o'
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00}, // 0x70 'p'
    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00}, // 0x71 'q'
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00}, // 0x72 'r'
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00}, // 0x73 's'
    {0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00}, // 0x74 't'
    {0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, // 0x75 'u'
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00}, // 0x76 'v'
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00}, // 0x77 'w'
    {0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00}, // 0x78 'x'
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00}, // 0x79 'y'
    {0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00}, // 0x7A 'z'
    {0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00}, // 0x7B '{'
    {0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, // 0x7C '|'
    {0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00}, // 0x7D '}'
    {0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x7E '~'
    {0x00,0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00,0x00}, // 0x7F
};

// ============================================================================
// VGA 16 renk paleti → 32-bit RGB
// ============================================================================
static const uint32_t vga_palette[16] = {
    0x00000000,  // 0  Siyah
    0x000000AA,  // 1  Mavi
    0x0000AA00,  // 2  Yeşil
    0x0000AAAA,  // 3  Cyan
    0x00AA0000,  // 4  Kırmızı
    0x00AA00AA,  // 5  Magenta
    0x00AA5500,  // 6  Kahverengi
    0x00AAAAAA,  // 7  Açık gri
    0x00555555,  // 8  Koyu gri
    0x005555FF,  // 9  Açık mavi
    0x0055FF55,  // 10 Açık yeşil
    0x0055FFFF,  // 11 Açık cyan
    0x00FF5555,  // 12 Açık kırmızı
    0x00FF55FF,  // 13 Açık magenta
    0x00FFFF55,  // 14 Sarı
    0x00FFFFFF,  // 15 Beyaz
};

// ============================================================================
// İç durum
// ============================================================================
#define FONT_WIDTH  8
#define FONT_HEIGHT 16

// Scroll back buffer boyutu (satır cinsinden)
#define SCROLL_BACK_LINES 500

static uint8_t*  fb     = (uint8_t*)0;  // framebuffer başlangıç adresi
static uint32_t  fb_w   = 0;            // genişlik (pixel)
static uint32_t  fb_h   = 0;            // yükseklik (pixel)
static uint32_t  fb_p   = 0;            // pitch (satır başına byte)
static uint8_t   fb_bpp = 32;           // bit per pixel

// Karakter grid boyutu
static size_t cols = 0;  // sütun sayısı
static size_t rows = 0;  // satır sayısı

// Cursor pozisyonu
static size_t cur_col = 0;
static size_t cur_row = 0;

// Mevcut renk (VGA renk byte'ı: yüksek nibble = bg, düşük nibble = fg)
static uint8_t cur_color = 0x07;  // açık gri ön plan, siyah arka plan

// Yazılımsal cursor (alttaki pixel satırında cursor çizgisi)
static int cursor_visible = 1;

// ============================================================================
// Scroll back buffer
// Her "satır" COLS adet {char, color} ikilisi içerir.
// ============================================================================
typedef struct {
    uint8_t ch;
    uint8_t color;
} Cell;

// Aktif ekran içeriği (karakter hücreleri)
// Maksimum 240x68 = ~16KB, stack'te değil BSS'de tutulur
#define MAX_COLS 240
#define MAX_ROWS 68

static Cell screen_cells[MAX_ROWS][MAX_COLS];

// Scroll back buffer: geçmiş satırlar
static Cell scroll_back[SCROLL_BACK_LINES][MAX_COLS];
static size_t scroll_back_count = 0;   // buffer'da kaç satır var
static size_t scroll_view_offset = 0;  // şu an kaç satır geri bakıyoruz

// Forward declarations
void update_cursor64(void);
void clear_screen64(void);

// ============================================================================
// I/O portları (cursor için — VESA'da yazılımsal cursor kullanıyoruz)
// ============================================================================
static inline void outb(uint16_t port, uint8_t val) {
    __asm__ volatile ("outb %0, %1" : : "a"(val), "Nd"(port));
}
static inline uint8_t inb(uint16_t port) {
    uint8_t ret;
    __asm__ volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

// ============================================================================
// Düşük seviyeli pixel yazma
// ============================================================================

// Tek bir piksel yaz (32bpp varsayılır, 24bpp de desteklenir)
static inline void put_pixel(uint32_t x, uint32_t y, uint32_t color) {
    if (x >= fb_w || y >= fb_h) return;

    uint8_t* ptr = fb + y * fb_p + x * (fb_bpp / 8);

    if (fb_bpp == 32) {
        *(uint32_t*)ptr = color;
    } else if (fb_bpp == 24) {
        ptr[0] = color & 0xFF;
        ptr[1] = (color >> 8) & 0xFF;
        ptr[2] = (color >> 16) & 0xFF;
    }
}

// ============================================================================
// Font glyph çizimi
// ============================================================================
static void draw_char_at_pixel(uint32_t px, uint32_t py,
                                char c, uint8_t color_byte) {
    uint32_t fg = vga_palette[color_byte & 0x0F];
    uint32_t bg = vga_palette[(color_byte >> 4) & 0x07];

    // Geçerli ASCII aralığı kontrolü
    uint8_t idx = (uint8_t)c;
    if (idx < 32 || idx > 127) idx = 32;  // bilinmeyen → boşluk
    const uint8_t* glyph = font8x16[idx - 32];

    for (int row = 0; row < FONT_HEIGHT; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < FONT_WIDTH; col++) {
            uint32_t pcolor = (bits & (0x80 >> col)) ? fg : bg;
            put_pixel(px + col, py + row, pcolor);
        }
    }
}

// Karakter koordinatından piksel koordinatına
static inline uint32_t char_to_px(size_t col) { return (uint32_t)(col * FONT_WIDTH);  }
static inline uint32_t char_to_py(size_t row) { return (uint32_t)(row * FONT_HEIGHT); }

// ============================================================================
// Hücre tabanlı çizim
// ============================================================================

// Ekrandaki tek bir hücreyi yeniden çiz
static void redraw_cell(size_t row, size_t col) {
    if (row >= rows || col >= cols) return;
    Cell* c = &screen_cells[row][col];
    draw_char_at_pixel(char_to_px(col), char_to_py(row), c->ch, c->color);
}

// Tüm ekranı hücrelerden yeniden çiz
static void redraw_all(void) {
    for (size_t r = 0; r < rows; r++)
        for (size_t c = 0; c < cols; c++)
            redraw_cell(r, c);
    // Cursor çiz
    update_cursor64();
}

// ============================================================================
// Cursor (yazılımsal: son satırda 2px yüksek beyaz çizgi)
// ============================================================================
void update_cursor64(void) {
    if (!cursor_visible) return;

    uint32_t px = char_to_px(cur_col);
    uint32_t py = char_to_py(cur_row);

    // Cursor: karakterin altındaki 2 piksel satırı
    uint32_t cursor_color = vga_palette[cur_color & 0x0F];
    for (int i = 0; i < 2; i++) {
        uint32_t cy = py + FONT_HEIGHT - 2 + i;
        for (int x = 0; x < FONT_WIDTH; x++) {
            put_pixel(px + x, cy, cursor_color);
        }
    }
}

// Cursor'un üstündeki hücreyi yeniden çizerek cursor'u sil
static void erase_cursor(void) {
    if (cur_row < rows && cur_col < cols)
        redraw_cell(cur_row, cur_col);
}

// ============================================================================
// Scroll
// ============================================================================

// Ekranı 1 satır yukarı kaydır, en alta boş satır ekle
static void scroll_screen_up(void) {
    // En üst satırı scroll_back buffer'a kaydet
    if (scroll_back_count < SCROLL_BACK_LINES) {
        for (size_t c = 0; c < cols; c++)
            scroll_back[scroll_back_count][c] = screen_cells[0][c];
        scroll_back_count++;
    } else {
        // Buffer doluysa en eskisini at (dairesel değil, shift yap)
        for (size_t i = 0; i < SCROLL_BACK_LINES - 1; i++)
            for (size_t c = 0; c < cols; c++)
                scroll_back[i][c] = scroll_back[i+1][c];
        for (size_t c = 0; c < cols; c++)
            scroll_back[SCROLL_BACK_LINES-1][c] = screen_cells[0][c];
    }

    // Hücreleri 1 satır yukarı kaydır
    for (size_t r = 0; r < rows - 1; r++)
        for (size_t c = 0; c < cols; c++)
            screen_cells[r][c] = screen_cells[r+1][c];

    // Son satırı temizle
    for (size_t c = 0; c < cols; c++) {
        screen_cells[rows-1][c].ch    = ' ';
        screen_cells[rows-1][c].color = cur_color;
    }

    // Framebuffer'ı 64-bit adımlarla kaydır (hızlı memmove)
    uint32_t line_bytes = (uint32_t)(FONT_HEIGHT * fb_p);
    uint64_t* src64 = (uint64_t*)(fb + line_bytes);
    uint64_t* dst64 = (uint64_t*)fb;
    uint32_t total64 = (line_bytes * (uint32_t)(rows - 1)) / 8;
    for (uint32_t i = 0; i < total64; i++)
        dst64[i] = src64[i];
    // Son satırı arkaplan rengiyle doldur
    uint32_t bg = vga_palette[(cur_color >> 4) & 0x07];
    uint64_t bg64 = ((uint64_t)bg << 32) | bg;
    uint64_t* last64 = (uint64_t*)(fb + (uint32_t)(rows-1) * line_bytes);
    uint32_t fill64 = (fb_p * FONT_HEIGHT) / 8;
    for (uint32_t i = 0; i < fill64; i++)
        last64[i] = bg64;
}

// ============================================================================
// Yeni satır
// ============================================================================
static void do_newline(void) {
    cur_col = 0;
    cur_row++;
    if (cur_row >= rows) {
        cur_row = rows - 1;
        scroll_screen_up();
    }
}

// ============================================================================
// Dışa açık API
// ============================================================================

void init_vesa64(void) {
    fb     = (uint8_t*)(uintptr_t)framebuffer_addr;
    fb_w   = framebuffer_width;
    fb_h   = framebuffer_height;
    fb_p   = framebuffer_pitch;
    fb_bpp = framebuffer_bpp;

    // Framebuffer yoksa (VESA desteklenmiyorsa) güvenli çıkış
    if (!fb || fb_w == 0 || fb_h == 0) return;

    // Karakter grid boyutu
    cols = fb_w / FONT_WIDTH;
    rows = fb_h / FONT_HEIGHT;
    if (cols > MAX_COLS) cols = MAX_COLS;
    if (rows > MAX_ROWS) rows = MAX_ROWS;

    cur_color = 0x07;  // açık gri fg, siyah bg
    scroll_back_count  = 0;
    scroll_view_offset = 0;

    clear_screen64();
}

void clear_screen64(void) {
    // Tüm hücreleri temizle
    for (size_t r = 0; r < rows; r++) {
        for (size_t c = 0; c < cols; c++) {
            screen_cells[r][c].ch    = ' ';
            screen_cells[r][c].color = cur_color;
        }
    }
    cur_row = 0;
    cur_col = 0;
    scroll_view_offset = 0;

    // Framebuffer'ı arkaplan rengiyle doldur
    uint32_t bg = vga_palette[(cur_color >> 4) & 0x07];
    uint32_t total_pixels = fb_p * fb_h;
    for (uint32_t i = 0; i < total_pixels; i += 4)
        *(uint32_t*)(fb + i) = bg;
}

void set_color64(uint8_t fg, uint8_t bg) {
    cur_color = (uint8_t)((bg & 0x07) << 4) | (fg & 0x0F);
}

void set_position64(size_t row, size_t col) {
    if (row >= rows) row = rows - 1;
    if (col >= cols) col = cols - 1;
    erase_cursor();
    cur_row = row;
    cur_col = col;
    update_cursor64();
}

void get_position64(size_t* row, size_t* col) {
    if (row) *row = cur_row;
    if (col) *col = cur_col;
}

void get_screen_size64(size_t* width, size_t* height) {
    if (width)  *width  = cols;
    if (height) *height = rows;
}

// Sadece hücre dizisini günceller, framebuffer'a yazmaz
static void putchar_cell(char c, uint8_t color) {
    if (c == '\n') { do_newline(); return; }
    if (c == '\r') { cur_col = 0; return; }
    if (c == '\t') {
        size_t next_tab = (cur_col + 4) & ~(size_t)3;
        if (next_tab >= cols) next_tab = cols - 1;
        while (cur_col < next_tab) {
            screen_cells[cur_row][cur_col].ch    = ' ';
            screen_cells[cur_row][cur_col].color = color;
            cur_col++;
        }
        return;
    }
    if (c == '\b') {
        if (cur_col > 0) {
            cur_col--;
            screen_cells[cur_row][cur_col].ch    = ' ';
            screen_cells[cur_row][cur_col].color = color;
        }
        return;
    }
    screen_cells[cur_row][cur_col].ch    = c;
    screen_cells[cur_row][cur_col].color = color;
    cur_col++;
    if (cur_col >= cols) do_newline();
}

// Tek karakter — anında ekrana yaz (prompt, kullanıcı girişi için)
void putchar64(char c, uint8_t color) {
    erase_cursor();
    putchar_cell(c, color);
    redraw_cell(cur_row, cur_col > 0 ? cur_col - 1 : 0);
    if (c == '\n' || c == '\r' || c == '\b' || c == '\t')
        redraw_all();
    update_cursor64();
}

void print_str64(const char* str, uint8_t color) {
    erase_cursor();
    size_t r0 = cur_row;
    while (*str)
        putchar_cell(*str++, color);
    // r0'dan cur_row'a kadar olan satırları çiz
    size_t r1 = cur_row;
    if (r1 >= rows) r1 = rows - 1;
    for (size_t r = r0; r <= r1; r++)
        for (size_t c = 0; c < cols; c++)
            redraw_cell(r, c);
    update_cursor64();
}

void println64(const char* str, uint8_t color) {
    erase_cursor();
    size_t r0 = cur_row;
    while (*str)
        putchar_cell(*str++, color);
    putchar_cell('\n', color);
    // r0'dan önceki satıra kadar çiz (newline sonrası cur_row arttı)
    size_t r1 = (cur_row > 0) ? cur_row - 1 : 0;
    if (r1 >= rows) r1 = rows - 1;
    if (r0 > r1) r0 = r1;
    for (size_t r = r0; r <= r1; r++)
        for (size_t c = 0; c < cols; c++)
            redraw_cell(r, c);
    update_cursor64();
}

// ============================================================================
// Scroll API
// ============================================================================

void scroll_up(size_t lines) {
    if (scroll_view_offset + lines > scroll_back_count)
        lines = scroll_back_count - scroll_view_offset;
    if (lines == 0) return;

    scroll_view_offset += lines;

    // scroll_back'ten ekrana göster
    // Önce aktif ekranı geçici olarak "aşağı" ötele, üste history göster
    // Basit yaklaşım: tüm ekranı yeniden çiz
    // -- Görüntülenen satırlar scroll_back'in sonundan scroll_view_offset önünde --
    size_t view_start_in_back = scroll_back_count - scroll_view_offset;

    // Ekranı tamamen karıştırma: sadece framebuffer'ı güncelle
    for (size_t r = 0; r < rows; r++) {
        size_t src_row_in_back = view_start_in_back + r;
        for (size_t c = 0; c < cols; c++) {
            Cell cell;
            if (src_row_in_back < scroll_back_count) {
                cell = scroll_back[src_row_in_back][c];
            } else {
                // scroll_back bitti, aktif ekrandan al
                size_t active_r = src_row_in_back - scroll_back_count;
                cell = (active_r < rows) ? screen_cells[active_r][c]
                                         : (Cell){' ', cur_color};
            }
            draw_char_at_pixel(char_to_px(c), char_to_py(r), cell.ch, cell.color);
        }
    }
}

void scroll_down(size_t lines) {
    if (lines > scroll_view_offset) lines = scroll_view_offset;
    if (lines == 0) return;

    scroll_view_offset -= lines;

    if (scroll_view_offset == 0) {
        // Normal görünüme dön
        redraw_all();
    } else {
        // Aynı mantıkla yeniden çiz
        size_t view_start_in_back = scroll_back_count - scroll_view_offset;
        for (size_t r = 0; r < rows; r++) {
            size_t src_row_in_back = view_start_in_back + r;
            for (size_t c = 0; c < cols; c++) {
                Cell cell;
                if (src_row_in_back < scroll_back_count) {
                    cell = scroll_back[src_row_in_back][c];
                } else {
                    size_t active_r = src_row_in_back - scroll_back_count;
                    cell = (active_r < rows) ? screen_cells[active_r][c]
                                             : (Cell){' ', cur_color};
                }
                draw_char_at_pixel(char_to_px(c), char_to_py(r), cell.ch, cell.color);
            }
        }
    }
}

void get_scroll_info64(size_t* buffer_lines, size_t* offset) {
    if (buffer_lines) *buffer_lines = scroll_back_count;
    if (offset)       *offset       = scroll_view_offset;
}

// ============================================================================
// VGA uyumluluk stub'ları
// (Eski kod bu fonksiyonları çağırıyorsa hata vermemesi için)
// ============================================================================
void reset_to_standard_mode(void) { /* VESA'da gerek yok */ }
void set_extended_text_mode(void)  { /* VESA'da gerek yok */ }

// Renk indeks dönüştürücü (dışarıdan çağrılabilir)
uint32_t vesa_color_from_vga(uint8_t idx) {
    return vga_palette[idx & 0x0F];
}